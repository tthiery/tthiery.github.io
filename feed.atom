<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>http://tthiery.github.io/</id>
	<title>My Blog</title>
	<link rel="self" href="http://tthiery.github.io/" />
	<rights>2020</rights>
	<updated>2020-07-19T12:32:50Z</updated>
	<subtitle>Welcome!</subtitle>
	<entry>
		<id>http://tthiery.github.io/posts/2020/07/01/xunit-with-generic-paramter</id>
		<title>xUnit Theories with Type Parameters</title>
		<link href="http://tthiery.github.io/posts/2020/07/01/xunit-with-generic-paramter" />
		<updated>2020-07-01T00:00:00Z</updated>
		<content>&lt;p&gt;When unit testing generic protocols like the &lt;a href="https://lego.github.io/lego-ble-wireless-protocol-docs"&gt;Lego Wireless Protocol&lt;/a&gt; input values might be lead to different expected values. Sometimes, however, not only the value changes but also the data types of what to expect. xUnit's &lt;code&gt;Assert.Equal(expected, actual)&lt;/code&gt; methods has overloads for countless basic data types like &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; and elementary support for enums. To activate these, the expected argument would need to be parameterized with the right data type.&lt;/p&gt;
&lt;p&gt;While this works quite nice when using fixed unit tests where the actual/expected data type is part of the method, for xUnit &lt;strong&gt;theories&lt;/strong&gt; it need some more infrastructure in form of adding a type parameter to the unit test method.&lt;/p&gt;
&lt;p&gt;Here an extract from the unit testing from the &lt;a href="https://github.com/sharpbrick/powered-up"&gt;sharpbrick/powered-up&lt;/a&gt; library.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Theory]
[InlineData(&amp;quot;06-00-01-02-06-00&amp;quot;, HubProperty.Button, HubPropertyOperation.Update, false)]
[InlineData(&amp;quot;06-00-01-02-06-01&amp;quot;, HubProperty.Button, HubPropertyOperation.Update, true)]
[InlineData(&amp;quot;06-00-01-05-06-61&amp;quot;, HubProperty.Rssi, HubPropertyOperation.Update, (sbyte)97)]
[InlineData(&amp;quot;06-00-01-06-06-64&amp;quot;, HubProperty.BatteryVoltage, HubPropertyOperation.Update, (byte)100)]
[InlineData(&amp;quot;06-00-01-07-06-00&amp;quot;, HubProperty.BatteryType, HubPropertyOperation.Update, BatteryType.Normal)]
[InlineData(&amp;quot;06-00-01-07-06-01&amp;quot;, HubProperty.BatteryType, HubPropertyOperation.Update, BatteryType.RechargeableBlock)]
[InlineData(&amp;quot;06-00-01-0B-06-80&amp;quot;, HubProperty.SystemTypeId, HubPropertyOperation.Update, SystemType.LegoTechnic_MediumHub)]
[InlineData(&amp;quot;06-00-01-0C-06-00&amp;quot;, HubProperty.HardwareNetworkId, HubPropertyOperation.Update, (byte)0)]
public void HubPropertiesEncoder_Decode_UpdateUpstream&amp;lt;T&amp;gt;(string messageAsString, HubProperty expectedProperty, HubPropertyOperation expectedPropertyOperation, T payload)
{
    // arrange
    var data = BytesStringUtil.StringToData(messageAsString).AsSpan().Slice(3);

    // act
    var message = new HubPropertiesEncoder().Decode(0x00, data) as HubPropertyMessage&amp;lt;T&amp;gt;;

    // assert
    Assert.Equal(expectedProperty, message.Property);
    Assert.Equal(expectedPropertyOperation, message.Operation);
    Assert.Equal(payload, message.Payload);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;payload&lt;/code&gt; parameter has a data type bound to a generic. When invoking the &lt;code&gt;[Theory]&lt;/code&gt; xUnit will actually instanciate the function with the suitable type parameter. As above, sometimes the &lt;code&gt;[InlineData(...)]&lt;/code&gt; entry needs to be hinted (e.g. &lt;code&gt;(sbyte)97&lt;/code&gt;), when C# defaults might lead to a wrong data type (e.g. &lt;code&gt;97&lt;/code&gt; is of data type &lt;code&gt;int&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When the &lt;code&gt;Attribute&lt;/code&gt;s of C# do not allow to instantiate a data type (typically classes), a adapter shim might help:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Theory]
[InlineData(&amp;quot;09-00-01-03-06-00-00-00-11&amp;quot;, HubProperty.FwVersion, HubPropertyOperation.Update, &amp;quot;1.1.0.0&amp;quot;)]
[InlineData(&amp;quot;09-00-01-04-06-00-00-00-07&amp;quot;, HubProperty.HwVersion, HubPropertyOperation.Update, &amp;quot;0.7.0.0&amp;quot;)]
[InlineData(&amp;quot;07-00-01-0A-06-00-03&amp;quot;, HubProperty.LegoWirelessProtocolVersion, HubPropertyOperation.Update, &amp;quot;3.0&amp;quot;)]
public void HubPropertiesEncoder_Decode_UpdateUpstream_VersionShim(string messageAsString, HubProperty expectedProperty, HubPropertyOperation expectedPropertyOperation, string payload)
    =&amp;gt; HubPropertiesEncoder_Decode_UpdateUpstream(messageAsString, expectedProperty, expectedPropertyOperation, new Version(payload));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; I google. This feature was surely somewhere mentioned before. I do not reference the material I googled, because I lost the link.&lt;/em&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;When unit testing generic protocols like the &lt;a href="https://lego.github.io/lego-ble-wireless-protocol-docs"&gt;Lego Wireless Protocol&lt;/a&gt; input values might be lead to different expected values. Sometimes, however, not only the value changes but also the data types of what to expect. xUnit's &lt;code&gt;Assert.Equal(expected, actual)&lt;/code&gt; methods has overloads for countless basic data types like &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; and elementary support for enums. To activate these, the expected argument would need to be parameterized with the right data type.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://tthiery.github.io/posts/2020/06/12/reactivex-middlewares</id>
		<title>ReactiveX Middlewares</title>
		<link href="http://tthiery.github.io/posts/2020/06/12/reactivex-middlewares" />
		<updated>2020-06-12T00:00:00Z</updated>
		<content>&lt;p&gt;While implementing &lt;a href="https://github.com/sharpbrick/powered-up"&gt;sharpbrick/powered-up&lt;/a&gt; an interesting problem came up to solve: How to handle the incoming messages of the Bluetooth Low Energy based communication protocol. On top of the Bluetooth abstraction there is a simple callback which would receive roughly 50 different message types which would need dispatching to several locations, some locations would even spawn up dynamically over time. I needed an infrastructure! I needed a middleware 😀.&lt;/p&gt;
&lt;h2 id="possible-solutions"&gt;Possible Solutions&lt;/h2&gt;
&lt;p&gt;Within the tighter .NET ecosystem (a.k.a. everything what Microsoft and close friends throw at us) there are the following libraries for push based messaging:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;System.Reactive&lt;/code&gt;&lt;/strong&gt;: The .NET implementation part (and godfather) of the ReactiveX project (e.g. JavaScript: &lt;code&gt;rxjs&lt;/code&gt;). The library is push-based, threading/buffering is optional, allow optional subscription, supports LINQ, allow building dynamic pipelines but is heap based.&lt;/li&gt;
&lt;li&gt;ASP.NET Core &lt;strong&gt;middleware&lt;/strong&gt; stack. Unfortunately, in the current state bound to HTTP. Standalone implementations like &lt;a href="https://github.com/violetgrass/middleware"&gt;violetgrass/middleware&lt;/a&gt; (disclaimer: another side project) make the basic concept available to other server/dispatcher applications.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.Threading.Channels&lt;/code&gt;: A part of the ASP.NET Core stack, focused on channeling data between separate producer and consumer threads. The library is push- and pull-based, buffering is including, requires active consumers and does not support LINQ.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="middlewares"&gt;Middlewares&lt;/h2&gt;
&lt;p&gt;Ignoring &lt;code&gt;System.Threading.Channels&lt;/code&gt; for now, both &lt;code&gt;System.Reactive&lt;/code&gt; and ASP.NET Core compiled middlewares are basically methods to build a series of functions between the place of source and an ultimate target&lt;/p&gt;
&lt;p&gt;A compiled middleware is build upfront and is optimized on efficiency&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class QueueMessageContext : Context
{
    public Message Message { get; set; }
}

var stack = new MiddlewareBuilder&amp;lt;QueueMessageContext&amp;gt;()
    // middleware step
    .Use(async (context, next) =&amp;gt; {
        // do something with the context.Message
        await next(context); 
    })
    // middleware step
    .Use(async (context, next) =&amp;gt; {
        // do something with the context.Message
        await next(context); 
    })
    // final handling of message
    .Use(async (context, next) =&amp;gt; {
        // do something with the context.Message
    })
    .Build();

// invoke
var x = new QueueMessageContext() { Message = msg, };

await stack(x); // the whole stack is essentially a stacked function delegate. no magic anymore. no overhead despite millions of requests.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;System.Reactive&lt;/code&gt; middlewares can be dynamically constructed&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var source = new Subject&amp;lt;Message&amp;gt;();

var firstPart = source
    .Select(msg =&amp;gt; { /* do something */ return msg; }); // middleware step

// somewhere else (e.g. on demand)
var d = firstPart
    .Select(msg =&amp;gt; { /* do something */ return msg; }) // middleware step
    .Subscribe(msg =&amp;gt; /* do something */); // final handling of message

// invoke
source.next(msg); // subscriptions are checked, data is boxed, heap is allocated, ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While a compiled middleware has the benefits of performance, a reactive stream can be dynamically composed, filtered and combined (like known from LINQ). It also allows multiple subscriptions which an ASP.NET Core middleware does not. However, there is also a disadvantage: It does not support async/await and will block the producer (exept explictely configured with &lt;code&gt;.ObserveOn&lt;/code&gt;). It does not naturally fit to the common &lt;code&gt;async/await&lt;/code&gt; programming pattern in C#.&lt;/p&gt;
&lt;p&gt;Within &lt;a href="https://github.com/sharpbrick/powered-up"&gt;sharpbrick/powered-up&lt;/a&gt; there is a critical requirement to dynamically compose pipelines of the incoming upstream messages to models representing PoweredUP hubs and devices.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;&lt;code&gt;System.Reactive&lt;/code&gt; is therefore the right choice to use within the library. The library behaves similar to a user interface (PoweredUP devices &amp;lt;-&amp;gt; UI controls) with external influences. In the world of UI progamming, the reactive programming model is used by all currently popular frameworks  (React (Native), Angular, ...).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For consumers of the library however, the &lt;code&gt;SharpBrick.PoweredUp&lt;/code&gt; library exposes an async/await based interface for invocations. Internally, the library converts the subscriptions to the reactive stream into an &lt;em&gt;awaiter&lt;/em&gt; using &lt;code&gt;.GetAwaiter()&lt;/code&gt; as seen below in a request/response matching algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static async Task&amp;lt;TResultMessage&amp;gt; SendMessageReceiveResultAsync&amp;lt;TResultMessage&amp;gt;(this IPoweredUpProtocol self, PoweredUpMessage requestMessage, Func&amp;lt;TResultMessage, bool&amp;gt; filter = default)
{
    // UpstreamMessages is an IObservable
    var awaitable = self.UpstreamMessages
        .OfType&amp;lt;TResultMessage&amp;gt;()
        .Where(responseMessage =&amp;gt; filter == null || filter(responseMessage))
        .FirstAsync() // only the first message observed is forwarded
        .GetAwaiter(); // make sure the subscription is present at the moment the message is sent.

    await self.SendMessageAsync(requestMessage);

    var response = await awaitable; // subscription is discarded

    return response;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;When building an application or a library with many variable exit points - may it be UI controls or other model endpoints - for an incoming data stream, using &lt;code&gt;System.Reactive&lt;/code&gt; is the right choice.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;While implementing &lt;a href="https://github.com/sharpbrick/powered-up"&gt;sharpbrick/powered-up&lt;/a&gt; an interesting problem came up to solve: How to handle the incoming messages of the Bluetooth Low Energy based communication protocol. On top of the Bluetooth abstraction there is a simple callback which would receive roughly 50 different message types which would need dispatching to several locations, some locations would even spawn up dynamically over time. I needed an infrastructure! I needed a middleware 😀.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://tthiery.github.io/posts/2020/05/21/platformio-with-git</id>
		<title>Using PlatformIO and Git</title>
		<link href="http://tthiery.github.io/posts/2020/05/21/platformio-with-git" />
		<updated>2020-05-21T00:00:00Z</updated>
		<content>&lt;p&gt;When working on my private PlatformIO project for a watertank sensor, I repeatingly struggled with how to manage the source code. PlatformIO is unfortunately not very clear explaining this topic.&lt;/p&gt;
&lt;p&gt;Simplified, the &lt;code&gt;platform.ini&lt;/code&gt; contains references to the utilized SDKs and library dependencies. The only PlatformIO artifact are the &lt;code&gt;platform.ini&lt;/code&gt; and the entry in the &lt;code&gt;extensions.json&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; however, will have to contain some entries to avoid commiting the cached PlatformIO is using in form of &lt;code&gt;.pio&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="file-to-add-to-source-control"&gt;File to add to source control&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.vscode
&lt;ul&gt;
&lt;li&gt;extensions.json&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;src/* (your source code)&lt;/li&gt;
&lt;li&gt;headers/* (your header)&lt;/li&gt;
&lt;li&gt;platform.ini&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="files-in.gitignore"&gt;Files in &lt;code&gt;.gitignore&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.pio (excluding all the cached libraries and board files)&lt;/li&gt;
&lt;li&gt;.vscode/c_cpp_properties.json (cache over all C artifacts)&lt;/li&gt;
&lt;li&gt;.vscode/launch.json (hardcoded to local directory by default)&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;When working on my private PlatformIO project for a watertank sensor, I repeatingly struggled with how to manage the source code. PlatformIO is unfortunately not very clear explaining this topic.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://tthiery.github.io/posts/2019/01/23/first-post</id>
		<title>First Post</title>
		<link href="http://tthiery.github.io/posts/2019/01/23/first-post" />
		<updated>2019-01-23T00:00:00Z</updated>
		<content>&lt;p&gt;This is my first post!&lt;/p&gt;
&lt;script src="https://gist.github.com/tthiery/2426b191135b4403c5f305727366cecf.js?file=Bar.cs"&gt;&lt;/script&gt;
</content>
		<summary>&lt;p&gt;This is my first post!&lt;/p&gt;</summary>
	</entry>
</feed>